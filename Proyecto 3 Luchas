# Librerías estándar y externas
import tkinter as tk  # Proporciona widgets y ventana principal para la interfaz gráfica
from tkinter import ttk, messagebox  # ttk: widgets mejorados, messagebox: cuadros de diálogo
from PIL import Image, ImageTk  # Image: manipulación de imágenes, ImageTk: imágenes para Tkinter
from datetime import datetime  # Manejo de fechas y horas
import os  # Funciones del sistema de archivos: crear carpetas, verificar existencia, listar archivos
import random  # Funciones aleatorias: sample, uniform

# Lista de estadísticas posibles para los luchadores
ESTADISTICAS = [
    "Velocidad", "Fuerza", "Inteligencia", "Defensa", "Magia",
    "Telepatía", "Estratega", "Volar", "Elasticidad", "Regeneración"
]

#===================#
#Nombre: Luchador
#Atributos:
# tipo, genero, nombre_real, alter_ego, estadisticas, foto, victorias, derrotas, estadisticas
#Métodos:
# calcular_poder_total, luchar_contra
#===================#
class Luchador:
    def __init__(self, tipo, genero, nombre_real, alter_ego, estadisticas, foto=None):
        # Inicializa un luchador con sus datos y estadísticas
        self.tipo = tipo  # Héroe o Villano
        self.genero = genero  # Género del luchador
        self.nombre_real = nombre_real  # Nombre real
        self.alter_ego = alter_ego  # Nombre de superhéroe/villano
        self.foto = foto  # Ruta al icono
        self.estadisticas = estadisticas  # Diccionario de estadísticas
        self.victorias = 0  # Número de victorias
        self.derrotas = 0  # Número de derrotas
        self.objeto_estadisticas = Estadisticas(self)  # Objeto de estadísticas
    def calcular_poder_total(self):
        # Devuelve la suma de todas las estadísticas del luchador
        return sum(self.estadisticas.values())
    def luchar_contra(self, oponente):
        # Simula una lucha contra otro luchador y actualiza victorias/derrotas
        # random.uniform(a, b): número aleatorio entre a y b
        poder_propio = self.calcular_poder_total() * random.uniform(0.9, 1.1)
        poder_oponente = oponente.calcular_poder_total() * random.uniform(0.9, 1.1)
        if poder_propio > poder_oponente:
            self.victorias += 1
            oponente.derrotas += 1
            return (True, f"{self.alter_ego} derrotó a {oponente.alter_ego}!")
        else:
            self.derrotas += 1
            oponente.victorias += 1
            return (False, f"{oponente.alter_ego} derrotó a {self.alter_ego}!")

#===================#
#Nombre: CreadorPersonajes
#Atributos:
# ventana, funcion_guardar, tipo_var, genero_var, nombre_real_var, alter_ego_var, estadisticas_var, total_var, ruta_icono, etiqueta_icono, boton_icono, boton_guardar, etiqueta_total
#Métodos:
# crear_interfaz, actualizar_total, seleccionar_icono, seleccionar_icono_callback, guardar_personaje, nombre_existe
#===================#
class CreadorPersonajes:
    def __init__(self, ventana, funcion_guardar):
        # Ventana para crear un nuevo personaje
        self.ventana = ventana
        self.ventana.title("Crear Personaje")
        self.ventana.geometry("800x600")
        self.funcion_guardar = funcion_guardar
        self.tipo_var = tk.StringVar(value="Héroe")  # Variable de tipo para Combobox
        self.genero_var = tk.StringVar(value="Hombre")  # Variable de género para Combobox
        self.nombre_real_var = tk.StringVar()  # Variable para nombre real
        self.alter_ego_var = tk.StringVar()  # Variable para alter ego
        self.estadisticas_var = {estadistica: tk.IntVar(value=0) for estadistica in ESTADISTICAS}  # Diccionario de variables para sliders
        self.total_var = tk.StringVar(value="Total: 0")  # Variable para mostrar suma de estadísticas
        self.ruta_icono = None  # Ruta del icono seleccionado
        self.crear_interfaz()
    def crear_interfaz(self):
        # Construye la interfaz gráfica para crear personajes
        marco_principal = tk.Frame(self.ventana, padx=20, pady=20)
        marco_principal.pack(expand=True, fill=tk.BOTH)

        # Marco para la columna izquierda (datos básicos + icono TODO VERTICAL)
        marco_izquierdo = tk.Frame(marco_principal)
        marco_izquierdo.pack(side=tk.LEFT, fill=tk.Y, padx=10, pady=10)

        # DATOS BÁSICOS (vertical)
        tk.Label(marco_izquierdo, text="Datos Básicos", font=("Arial", 12, "bold")).pack(pady=10)

        tk.Label(marco_izquierdo, text="Tipo:").pack(anchor=tk.W)
        ttk.Combobox(
            marco_izquierdo, textvariable=self.tipo_var,
            values=["Héroe", "Villano"], state="readonly"
        ).pack(fill=tk.X, pady=5)

        tk.Label(marco_izquierdo, text="Género:").pack(anchor=tk.W)
        ttk.Combobox(
            marco_izquierdo, textvariable=self.genero_var,
            values=["Hombre", "Mujer", "No determinado"], state="readonly"
        ).pack(fill=tk.X, pady=5)

        tk.Label(marco_izquierdo, text="Nombre Real:").pack(anchor=tk.W)
        tk.Entry(marco_izquierdo, textvariable=self.nombre_real_var).pack(fill=tk.X, pady=5)

        tk.Label(marco_izquierdo, text="Alter Ego:").pack(anchor=tk.W)
        tk.Entry(marco_izquierdo, textvariable=self.alter_ego_var).pack(fill=tk.X, pady=5)

        # MARCO ICONO cuadrado pequeño debajo de datos básicos, en píxeles reales
        marco_icono = tk.Frame(marco_izquierdo, width=180, height=180)
        marco_icono.pack(pady=10)
        marco_icono.pack_propagate(False)  # Para que el marco NO se adapte al contenido

        self.etiqueta_icono = tk.Label(marco_icono, width=100, height=100, bd=2, relief="solid", bg="white")
        self.etiqueta_icono.pack(fill=tk.BOTH, expand=True)

        # El botón SIEMPRE debajo del icono, fuera del marco del icono
        self.boton_icono = tk.Button(
            marco_izquierdo, text="Seleccionar Icono",
            command=self.seleccionar_icono, height=1, width=16
        )
        self.boton_icono.pack(pady=(5, 0))

        # Marco derecho para estadísticas
        marco_derecho = tk.Frame(marco_principal)
        marco_derecho.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Indicador suma de estadísticas
        self.etiqueta_total = tk.Label(marco_derecho, textvariable=self.total_var, font=("Arial", 13, "bold"))
        self.etiqueta_total.pack(pady=(10, 5))

        tk.Label(marco_derecho, text="Estadísticas", font=("Arial", 12, "bold")).pack(pady=5)

        # Bucle for: crea un marco para cada estadística
        for estadistica in ESTADISTICAS:
            marco_estadistica = tk.Frame(marco_derecho)
            marco_estadistica.pack(fill=tk.X, pady=2)
            tk.Label(marco_estadistica, text=f"{estadistica}:", width=12, anchor=tk.W).pack(side=tk.LEFT)
            tk.Scale(
                marco_estadistica, from_=0, to=100, orient=tk.HORIZONTAL,
                variable=self.estadisticas_var[estadistica],
                command=self.actualizar_total,
                length=200
            ).pack(side=tk.LEFT, expand=True, fill=tk.X)
            tk.Label(marco_estadistica, textvariable=self.estadisticas_var[estadistica], width=3).pack(side=tk.LEFT)

        # Botón crear personaje (solo habilitado si suma == 100)
        self.boton_guardar = tk.Button(
            marco_derecho, text="CREAR PERSONAJE",
            command=self.guardar_personaje,
            bg="#4CAF50", fg="white",
            font=("Arial", 10, "bold"),
            height=1, width=20,
            state=tk.DISABLED
        )
        self.boton_guardar.pack(pady=20, side=tk.BOTTOM)

        # Inicializa estado del botón y total
        self.actualizar_total()

    def actualizar_total(self, _=None):
        # Actualiza la suma de estadísticas y habilita/deshabilita el botón de guardar
        total = sum(var.get() for var in self.estadisticas_var.values())
        self.total_var.set(f"Total: {total}")

        if total == 100:
            self.boton_guardar.config(state=tk.NORMAL)
            self.etiqueta_total.config(fg="green")
        else:
            self.boton_guardar.config(state=tk.DISABLED)
            self.etiqueta_total.config(fg="red")

    def seleccionar_icono(self):
        # Abre ventana para seleccionar icono desde la carpeta ICONOS
        carpeta_iconos = "ICONOS"
        if not os.path.exists(carpeta_iconos):
            os.makedirs(carpeta_iconos)  # Crea la carpeta si no existe
            messagebox.showinfo("Info", "Carpeta ICONOS creada. Agregue imágenes PNG.")
            return
        iconos = [f for f in os.listdir(carpeta_iconos) if f.lower().endswith('.png')]
        if not iconos:
            messagebox.showwarning("Error", "No hay iconos en la carpeta ICONOS")
            return
        ventana_iconos = tk.Toplevel(self.ventana)
        ventana_iconos.title("Seleccionar Icono")
        ventana_iconos.geometry("600x500")
        lienzo = tk.Canvas(ventana_iconos)  # Área desplazable
        barra_desplazamiento = tk.Scrollbar(ventana_iconos, orient="vertical", command=lienzo.yview)
        marco = tk.Frame(lienzo)
        lienzo.configure(yscrollcommand=barra_desplazamiento.set)
        lienzo.pack(side="left", fill="both", expand=True)
        barra_desplazamiento.pack(side="right", fill="y")
        lienzo.create_window((0, 0), window=marco, anchor="nw")
        marco.bind("<Configure>", lambda e: lienzo.configure(scrollregion=lienzo.bbox("all")))
        columnas = 4  # Número de columnas para mostrar iconos
        # Bucle for: recorre los iconos y crea botones con imagen
        for i, icono in enumerate(iconos):
            ruta_img = os.path.join(carpeta_iconos, icono)  # Ruta completa
            try:
                img = Image.open(ruta_img)  # Abre imagen
                img.thumbnail((120, 120))  # Redimensiona
                foto = ImageTk.PhotoImage(img)  # Convierte para Tkinter
                btn = tk.Button(marco, image=foto, command=lambda p=ruta_img: self.seleccionar_icono_callback(p, ventana_iconos))
                btn.image = foto  # Guarda referencia
                btn.grid(row=i//columnas, column=i%columnas, padx=5, pady=5)
            except Exception as e:
                print(f"Error cargando icono: {e}")

    def seleccionar_icono_callback(self, ruta, ventana):
        # Asigna el icono seleccionado y lo muestra en la interfaz
        self.ruta_icono = ruta
        try:
            img = Image.open(ruta)
            img = img.resize((200, 200), Image.Resampling.LANCZOS)
            photo = ImageTk.PhotoImage(img)
            self.etiqueta_icono.config(image=photo)
            self.etiqueta_icono.image = photo
            ventana.destroy()
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo cargar el icono: {e}")

    def guardar_personaje(self):
        # Guarda el personaje creado en el archivo y copia el icono
        alter_ego = self.alter_ego_var.get().strip()  # .strip(): elimina espacios
        if not alter_ego:
            messagebox.showwarning("Error", "¡El Alter Ego no puede estar vacío!")
            return
        if self.nombre_existe(alter_ego):
            messagebox.showerror("Error", "Este Alter Ego ya existe. Usa otro nombre.")
            return
        if not all([self.nombre_real_var.get(), alter_ego, self.ruta_icono]):
            messagebox.showwarning("Error", "Complete todos los campos y selecciona un icono.")
            return
        tipo = "H" if self.tipo_var.get() == "Héroe" else "V"
        genero = self.genero_var.get()[0]
        nombre_real = self.nombre_real_var.get()
        estadisticas = {k: v.get() for k, v in self.estadisticas_var.items()}
        # with open: abre archivo para agregar personaje
        with open("personajes.txt", "a") as f:
            stats_str = ",".join(str(estadisticas[k]) for k in ESTADISTICAS)
            f.write(f"{tipo},{genero},{nombre_real},{alter_ego},{stats_str}\n")
        iconos_pj_dir = "ICONOS_PERSONAJES"
        if not os.path.exists(iconos_pj_dir):
            os.makedirs(iconos_pj_dir)
        try:
            with Image.open(self.ruta_icono) as img:
                img.save(os.path.join(iconos_pj_dir, f"{alter_ego}.png"))
        except Exception as e:
            messagebox.showwarning("Advertencia", f"No se pudo guardar el icono: {e}")
        messagebox.showinfo("Éxito", "Personaje creado correctamente!")
        self.funcion_guardar()
        self.ventana.destroy()

    def nombre_existe(self, alter_ego):
        # Verifica si el alter ego ya existe en el archivo
        if not os.path.exists("personajes.txt"):
            return False
        # with open: abre archivo para leer personajes
        with open("personajes.txt", "r") as f:
            for linea in f:  # Bucle for: recorre cada línea del archivo
                datos = linea.strip().split(",")
                if len(datos) > 3 and datos[3].lower() == alter_ego.lower():
                    return True
        return False
[INSERTE SISTEMA TORNEO ]

#===================#
#Nombre: InicioSesion
#Atributos:
# ventana, marco, entrada_usuario, entrada_contrasena
#Métodos:
# __init__, crear_archivo_por_defecto, crear_widgets_login, validar_login, mostrar_bienvenida, abrir_sistema_torneos
#===================#            
class InicioSesion:
    """Clase que maneja el sistema de login y registro de usuarios."""
    
    def __init__(self, ventana):
        # Inicializa la ventana de login
        self.ventana = ventana
        self.ventana.title("Sistema de Login")
        self.ventana.geometry("400x300")
        
        if not os.path.exists("contraseñas.txt"):
            self.crear_archivo_por_defecto()
        
        self.crear_widgets_login()
    
    def crear_archivo_por_defecto(self):
        # Crea el archivo de contraseñas con usuarios por defecto
        with open("contraseñas.txt", "w", encoding="utf-8") as f:
            f.write("Sebas,Seb,1234\n")
            f.write("Hackney Hac,1234\n")
            f.write("admin,admin,admin\n")
    
    def crear_widgets_login(self):
        # Crea los widgets de la interfaz de login
        for widget in self.ventana.winfo_children():
            widget.destroy()
        
        self.frame = tk.Frame(self.ventana, padx=20, pady=20)
        self.frame.pack(expand=True)
        
        tk.Label(self.frame, text="INICIO DE SESIÓN", font=("Arial", 14, "bold")).grid(row=0, columnspan=2, pady=10)
        
        tk.Label(self.frame, text="Usuario:").grid(row=1, column=0, sticky="w", pady=5)
        self.usuario_entry = tk.Entry(self.frame)
        self.usuario_entry.grid(row=1, column=1, pady=5)
        
        tk.Label(self.frame, text="Contraseña:").grid(row=2, column=0, sticky="w", pady=5)
        self.contra_entry = tk.Entry(self.frame, show="*")
        self.contra_entry.grid(row=2, column=1, pady=5)
        
        tk.Button(self.frame, text="Ingresar", command=self.validar_login).grid(row=3, columnspan=2, pady=10)
    
    def validar_login(self):
        # Valida las credenciales ingresadas por el usuario
        usuario = self.usuario_entry.get()
        contra = self.contra_entry.get()
        
        if not usuario or not contra:
            messagebox.showwarning("Error", "Debe ingresar usuario y contraseña")
            return
        
        with open("contraseñas.txt", "r", encoding="utf-8") as f:
            for linea in f:
                datos = linea.strip().split(",")
                if len(datos) == 3:
                    nombre, user, password = datos
                    if user == usuario and password == contra:
                        self.mostrar_bienvenida(nombre)
                        return
        
        messagebox.showerror("Error", "Usuario o contraseña incorrectos")
    
    def mostrar_bienvenida(self, nombre):
        # Muestra la pantalla de bienvenida después del login
        for widget in self.ventana.winfo_children():
            widget.destroy()
        
        frame = tk.Frame(self.ventana, padx=20, pady=20)
        frame.pack(expand=True)
        
        tk.Label(
            frame, 
            text=f"¡Bienvenido/a {nombre}!", 
            font=("Arial", 16, "bold"),
            fg="blue"
        ).pack(pady=20)
        
        tk.Button(
            frame,
            text="Continuar al Menú Principal",
            command=self.abrir_sistema_torneos,
            width=20,
            height=2
        ).pack(pady=20)
    
    def abrir_sistema_torneos(self):
        # Inicia el sistema principal de torneos
        for widget in self.ventana.winfo_children():
            widget.destroy()
        
        SistemaTorneos(self.ventana)
#===================#
#Nombre: Lucha
#Atributos:
# primer_luchador, segundo_luchador, ganador_round_1, ganador_round_2, ganador_round_3, ganador_lucha, nombre_torneo
#Métodos:
# registrar_ganador, realizar_lucha, determinar_ganador
#===================#
class Lucha:
    def __init__(self, primer_luchador, segundo_luchador, nombre_torneo=None):
        # Inicializa una lucha entre dos luchadores
        if not isinstance(primer_luchador,Luchador) or not isinstance(segundo_luchador,Luchador):
            raise ValueError("Los nombres de los alter ego deben ser Luchadores")
        self.primer_luchador=primer_luchador
        self.segundo_luchador=segundo_luchador
        self.ganador_round_1=None
        self.ganador_round_2=None
        self.ganador_round_3=None
        self.ganador_lucha=None
        self.nombre_torneo=nombre_torneo or "Sin Torneo"
    def registrar_ganador(self,round_num,ganador):
        # Registra el ganador de un round
        if round_num == 1:
            self.ganador_round_1=ganador
        if round_num == 2:
            self.ganador_round_2=ganador
        if round_num == 3:
            self.ganador_round_3=ganador

        with open ("Luchas.txt","a") as archivo:
            archivo.write(self.primer_luchador.alter_ego + "," +self.segundo_luchador.alter_ego + "," +
                          "#"+ str(round_num)+"," + ganador+","+ self.nombre_torneo + "\n")
    def realizar_lucha(self):
        # Ejecuta la lucha entre los dos luchadores
        for round_num in range(1,4):
            stats_elegidos =random.sample(list(self.primer_luchador.stats.keys()),8)

            victorias_peleador1=0
            victorias_peleador2=0
            
            for stat in stats_elegidos:

                valor_peleador1=self.primer_luchador.stats.get(stat,0)
                valor_peleador2=self.segundo_luchador.stats.get(stat,0)

                if valor_peleador1 > valor_peleador2:
                    victorias_peleador1 +=1

                if valor_peleador2 > valor_peleador1:
                    victorias_peleador2 +=1
                    
            if victorias_peleador1 > victorias_peleador2:
                self.registrar_ganador(round_num,self.primer_luchador.alter_ego)
            
            if victorias_peleador2 > victorias_peleador1:
                self.registrar_ganador(round_num,self.segundo_luchador.alter_ego)

        self.determinar_ganador()

    def determinar_ganador(self):
        # Determina el ganador de la lucha basado en los rounds ganados
        primero_victorias= 0
        segundo_victorias=0

        for ganador in[self.ganador_round_1,self.ganador_round_2,self.ganador_round_3]:
            
            if ganador == self.primer_luchador.alter_ego:
                primero_victorias +=1
            elif ganador == self.segundo_luchador.alter_ego:
                segundo_victorias +=1
        if primero_victorias > segundo_victorias:
            self.ganador_lucha = self.primer_luchador.alter_ego
            
        elif segundo_victorias > primero_victorias:
            self.ganador_lucha = self.segundo_luchador.alter_ego
        else:
            self.ganador_lucha ="Empate"



MODOS_TORNEO = ["Manual", "Persona vs Programa", "Programa vs Programa"]

#===================#
#Nombre: Torneo
#Atributos:
# nombre, fecha, lugar, heroes, villanos, luchas, modo
#Métodos:
# resumen_txt
#===================#
class Torneo:
    def __init__(self, nombre, fecha, lugar, heroes, villanos, luchas, modo):
        # Inicializa un torneo con sus datos y participantes
        self.nombre = nombre
        self.fecha = fecha
        self.lugar = lugar
        self.heroes = heroes
        self.villanos = villanos
        self.luchas = luchas
        self.modo = modo

    def resumen_txt(self):
        # Devuelve un resumen de texto del torneo
        txt = []
        txt.append("==== TORNEO ====")
        txt.append(f"Nombre: {self.nombre}")
        txt.append(f"Fecha: {self.fecha}")
        txt.append(f"Lugar: {self.lugar}")
        txt.append(f"Modo: {self.modo}")
        txt.append(f"Número de luchas: {len(self.luchas)}")
        txt.append("Héroes:")
        for h in self.heroes:
            txt.append(f"  - {h.alter_ego}")
        txt.append("Villanos:")
        for v in self.villanos:
            txt.append(f"  - {v.alter_ego}")
        txt.append("Luchas:")
        for i, lucha in enumerate(self.luchas, 1):
            txt.append(f"  Lucha {i}: {lucha['heroe'].alter_ego} vs {lucha['villano'].alter_ego}")
        txt.append("================\n")
        return "\n".join(txt)

#===================#
#Nombre: Estadisticas
#Atributos:
# sistema_torneo
#Métodos:
# generar_reporte_completo, cantidad_torneos, cantidad_heroes, cantidad_villanos, heroe_mas_ganador, heroe_mas_perdedor, villano_mas_ganador, villano_mas_perdedor, heroe_mas_participante, villano_mas_participante
#===================#
class Estadisticas:
    def __init__(self, sistema_torneos):
        # Inicializa el objeto de estadísticas
        self.sistema = sistema_torneos

    def generar_reporte_completo(self):
        # Genera un diccionario con todas las estadísticas
        return {
            "torneos_realizados": self.cantidad_torneos(),
            "heroes_creados": self.cantidad_heroes(),
            "villanos_creados": self.cantidad_villanos(),
            "heroe_mas_ganador": self.heroe_mas_ganador(),
            "heroe_mas_perdedor": self.heroe_mas_perdedor(),
            "villano_mas_ganador": self.villano_mas_ganador(),
            "villano_mas_perdedor": self.villano_mas_perdedor(),
            "heroe_mas_participante": self.heroe_mas_participante(),
            "villano_mas_participante": self.villano_mas_participante()
        }

    def cantidad_torneos(self):
        # Retorna la cantidad de torneos realizados
        try:
            with open("Torneos.txt", "r") as f:
                return len(f.readlines())
        except FileNotFoundError:
            return 0

    def cantidad_heroes(self):
        # Retorna la cantidad de héroes creados
        return sum(1 for p in self.sistema.personajes if p.tipo == "Héroe")

    def cantidad_villanos(self):
        # Retorna la cantidad de villanos creados
        return sum(1 for p in self.sistema.personajes if p.tipo == "Villano")

    def heroe_mas_ganador(self):
        # Retorna el héroe con más victorias
        heroes = [p for p in self.sistema.personajes if p.tipo == "Héroe"]
        if not heroes:
            return "No hay héroes registrados"
        return max(heroes, key=lambda x: x.victorias).alter_ego

    def heroe_mas_perdedor(self):
        # Retorna el héroe con más derrotas
        heroes = [p for p in self.sistema.personajes if p.tipo == "Héroe"]
        if not heroes:
            return "No hay héroes registrados"
        return max(heroes, key=lambda x: x.derrotas).alter_ego

    def villano_mas_ganador(self):
        # Retorna el villano con más victorias
        villanos = [p for p in self.sistema.personajes if p.tipo == "Villano"]
        if not villanos:
            return "No hay villanos registrados"
        return max(villanos, key=lambda x: x.victorias).alter_ego

    def villano_mas_perdedor(self):
        # Retorna el villano con más derrotas
        villanos = [p for p in self.sistema.personajes if p.tipo == "Villano"]
        if not villanos:
            return "No hay villanos registrados"
        return max(villanos, key=lambda x: x.derrotas).alter_ego

    def heroe_mas_participante(self):
        # Retorna el héroe que aparece en más torneos
        participaciones = {}
        
        try:
            with open("Torneos.txt", "r") as f:
                for linea in f:
                    datos = linea.strip().split(',')
                    nombre_torneo = datos[0].strip("'")
                    
                    # Buscar en Luchas.txt las participaciones de este torneo
                    with open("Luchas.txt", "r") as l:
                        for lucha in l:
                            datos_lucha = lucha.strip().split(',')
                            if datos_lucha[4].strip() == nombre_torneo:
                                heroe = datos_lucha[0].strip()
                                participaciones[heroe] = participaciones.get(heroe, 0) + 1
        except FileNotFoundError:
            return "No hay datos de torneos"
            
        if not participaciones:
            return "No hay participaciones registradas"
            
        return max(participaciones.items(), key=lambda x: x[1])[0]

    def villano_mas_participante(self):
        # Retorna el villano que aparece en más torneos
        participaciones = {}
        
        try:
            with open("Torneos.txt", "r") as f:
                for linea in f:
                    datos = linea.strip().split(',')
                    nombre_torneo = datos[0].strip("'")
                    
                    # Buscar en Luchas.txt las participaciones de este torneo
                    with open("Luchas.txt", "r") as l:
                        for lucha in l:
                            datos_lucha = lucha.strip().split(',')
                            if datos_lucha[4].strip() == nombre_torneo:
                                villano = datos_lucha[1].strip()
                                participaciones[villano] = participaciones.get(villano, 0) + 1
        except FileNotFoundError:
            return "No hay datos de torneos"
            
        if not participaciones:
            return "No hay participaciones registradas"
            
        return max(participaciones.items(), key=lambda x: x[1])[0]

# Punto de entrada principal
if __name__ == "__main__":
    # Crea la ventana principal y lanza la aplicación
    ventana_principal = tk.Tk()
    sesion = InicioSesion(ventana_principal)
    ventana_principal.mainloop()

