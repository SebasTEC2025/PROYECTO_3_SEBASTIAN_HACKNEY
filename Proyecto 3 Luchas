import tkinter as tk
from tkinter import ttk, messagebox
from PIL import Image, ImageTk
import os
import random
from datetime import datetime


# Constante con las estadísticas
ESTADISTICAS = [
    "Velocidad", "Fuerza", "Inteligencia", "Defensa", "Magia",
    "Telepatía", "Estratega", "Volar", "Elasticidad", "Regeneración"
]

class Luchador:
    def __init__(self, tipo, genero, nombre_real, alter_ego, stats, foto=None):
        self.tipo = tipo
        self.genero = genero
        self.nombre_real = nombre_real
        self.alter_ego = alter_ego
        self.foto = foto
        self.stats = stats
        self.victorias = 0
        self.derrotas = 0
        self.estadisticas = Estadisticas(self)
    
    def calcular_poder_total(self):
        return sum(self.stats.values())
    
    def luchar_contra(self, oponente):
        poder_self = self.calcular_poder_total() * random.uniform(0.9, 1.1)
        poder_oponente = oponente.calcular_poder_total() * random.uniform(0.9, 1.1)
        
        if poder_self > poder_oponente:
            self.victorias += 1
            oponente.derrotas += 1
            return (True, f"{self.alter_ego} derrotó a {oponente.alter_ego}!")
        else:
            self.derrotas += 1
            oponente.victorias += 1
            return (False, f"{oponente.alter_ego} derrotó a {self.alter_ego}!")

class CreadorPersonajes:
    def __init__(self, root, callback_guardar):
        self.root = root
        self.root.title("Crear Personaje")
        self.root.geometry("800x600")
        self.callback_guardar = callback_guardar
        
        self.tipo_var = tk.StringVar(value="Héroe")
        self.genero_var = tk.StringVar(value="Hombre")
        self.nombre_real_var = tk.StringVar()
        self.alter_ego_var = tk.StringVar()
        self.stats_vars = {stat: tk.IntVar(value=0) for stat in ESTADISTICAS}
        self.total_var = tk.StringVar(value="Total: 0")
        self.icono_path = None
        
        self.crear_interfaz()

    def crear_interfaz(self):
        main_frame = tk.Frame(self.root, padx=20, pady=20)
        main_frame.pack(expand=True, fill=tk.BOTH)

        # Frame para la columna izquierda (datos básicos + icono TODO VERTICAL)
        left_frame = tk.Frame(main_frame)
        left_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10, pady=10)

        # DATOS BÁSICOS (vertical)
        tk.Label(left_frame, text="Datos Básicos", font=("Arial", 12, "bold")).pack(pady=10)

        tk.Label(left_frame, text="Tipo:").pack(anchor=tk.W)
        ttk.Combobox(
            left_frame, textvariable=self.tipo_var,
            values=["Héroe", "Villano"], state="readonly"
        ).pack(fill=tk.X, pady=5)

        tk.Label(left_frame, text="Género:").pack(anchor=tk.W)
        ttk.Combobox(
            left_frame, textvariable=self.genero_var,
            values=["Hombre", "Mujer", "No determinado"], state="readonly"
        ).pack(fill=tk.X, pady=5)

        tk.Label(left_frame, text="Nombre Real:").pack(anchor=tk.W)
        tk.Entry(left_frame, textvariable=self.nombre_real_var).pack(fill=tk.X, pady=5)

        tk.Label(left_frame, text="Alter Ego:").pack(anchor=tk.W)
        tk.Entry(left_frame, textvariable=self.alter_ego_var).pack(fill=tk.X, pady=5)

        # ICONO cuadrado pequeño debajo de datos básicos, en píxeles reales
        icon_frame = tk.Frame(left_frame, width=180, height=180)
        icon_frame.pack(pady=10)
        icon_frame.pack_propagate(False)  # Para que el frame NO se adapte al contenido

        self.lbl_icono = tk.Label(icon_frame, width=100, height=100, bd=2, relief="solid", bg="white")
        self.lbl_icono.pack(fill=tk.BOTH, expand=True)

        # El botón SIEMPRE debajo del icono, fuera del frame del icono
        self.btn_icono = tk.Button(
            left_frame, text="Seleccionar Icono",
            command=self.seleccionar_icono, height=1, width=16
        )
        self.btn_icono.pack(pady=(5, 0))

        # Frame derecha para estadísticas
        right_frame = tk.Frame(main_frame)
        right_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Indicador suma de stats
        self.total_label = tk.Label(right_frame, textvariable=self.total_var, font=("Arial", 13, "bold"))
        self.total_label.pack(pady=(10, 5))

        tk.Label(right_frame, text="Estadísticas", font=("Arial", 12, "bold")).pack(pady=5)

        for stat in ESTADISTICAS:
            frame_stat = tk.Frame(right_frame)
            frame_stat.pack(fill=tk.X, pady=2)
            tk.Label(frame_stat, text=f"{stat}:", width=12, anchor=tk.W).pack(side=tk.LEFT)
            tk.Scale(
                frame_stat, from_=0, to=100, orient=tk.HORIZONTAL,
                variable=self.stats_vars[stat],
                command=self.actualizar_total,
                length=200
            ).pack(side=tk.LEFT, expand=True, fill=tk.X)
            tk.Label(frame_stat, textvariable=self.stats_vars[stat], width=3).pack(side=tk.LEFT)

        # Botón crear personaje (solo habilitado si suma == 100)
        self.btn_guardar = tk.Button(
            right_frame, text="CREAR PERSONAJE",
            command=self.guardar_personaje,
            bg="#4CAF50", fg="white",
            font=("Arial", 10, "bold"),
            height=1, width=20,
            state=tk.DISABLED
        )
        self.btn_guardar.pack(pady=20, side=tk.BOTTOM)

        # Inicializa estado del botón y total
        self.actualizar_total()

    def actualizar_total(self, _=None):
        total = sum(var.get() for var in self.stats_vars.values())
        self.total_var.set(f"Total: {total}")

        if total == 100:
            self.btn_guardar.config(state=tk.NORMAL)
            self.total_label.config(fg="green")
        else:
            self.btn_guardar.config(state=tk.DISABLED)
            self.total_label.config(fg="red")

    def seleccionar_icono(self):
        iconos_dir = "ICONOS"
        if not os.path.exists(iconos_dir):
            os.makedirs(iconos_dir)
            messagebox.showinfo("Info", "Carpeta ICONOS creada. Agregue imágenes PNG.")
            return
        
        iconos = [f for f in os.listdir(iconos_dir) if f.lower().endswith('.png')]
        if not iconos:
            messagebox.showwarning("Error", "No hay iconos en la carpeta ICONOS")
            return
        
        top = tk.Toplevel(self.root)
        top.title("Seleccionar Icono")
        top.geometry("600x500")
        
        canvas = tk.Canvas(top)
        scrollbar = tk.Scrollbar(top, orient="vertical", command=canvas.yview)
        frame = tk.Frame(canvas)
        
        canvas.configure(yscrollcommand=scrollbar.set)
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        canvas.create_window((0, 0), window=frame, anchor="nw")
        frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        
        cols = 4
        for i, icono in enumerate(iconos):
            img_path = os.path.join(iconos_dir, icono)
            try:
                img = Image.open(img_path)
                img.thumbnail((120, 120))
                photo = ImageTk.PhotoImage(img)
                
                btn = tk.Button(frame, image=photo, 
                              command=lambda p=img_path: self.seleccionar_icono_callback(p, top))
                btn.image = photo
                btn.grid(row=i//cols, column=i%cols, padx=5, pady=5)
            except Exception as e:
                print(f"Error cargando icono: {e}")

    def seleccionar_icono_callback(self, path, top):
        self.icono_path = path
        try:
            img = Image.open(path)
            img = img.resize((200, 200), Image.Resampling.LANCZOS)
            photo = ImageTk.PhotoImage(img)
            self.lbl_icono.config(image=photo)
            self.lbl_icono.image = photo
            top.destroy()
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo cargar el icono: {e}")

    def guardar_personaje(self):
        alter_ego = self.alter_ego_var.get().strip()
        if not alter_ego:
            messagebox.showwarning("Error", "¡El Alter Ego no puede estar vacío!")
            return
            
        if self.nombre_existe(alter_ego):
            messagebox.showerror("Error", "Este Alter Ego ya existe. Usa otro nombre.")
            return
        
        if not all([self.nombre_real_var.get(), alter_ego, self.icono_path]):
            messagebox.showwarning("Error", "Complete todos los campos y selecciona un icono.")
            return
        
        tipo = "H" if self.tipo_var.get() == "Héroe" else "V"
        genero = self.genero_var.get()[0]
        nombre_real = self.nombre_real_var.get()
        stats = {k: v.get() for k, v in self.stats_vars.items()}
        
        with open("personajes.txt", "a") as f:
            stats_str = ",".join(str(stats[k]) for k in ESTADISTICAS)
            f.write(f"{tipo},{genero},{nombre_real},{alter_ego},{stats_str}\n")
        
        iconos_pj_dir = "ICONOS_PERSONAJES"
        if not os.path.exists(iconos_pj_dir):
            os.makedirs(iconos_pj_dir)
        
        try:
            with Image.open(self.icono_path) as img:
                img.save(os.path.join(iconos_pj_dir, f"{alter_ego}.png"))
        except Exception as e:
            messagebox.showwarning("Advertencia", f"No se pudo guardar el icono: {e}")
        
        messagebox.showinfo("Éxito", "Personaje creado correctamente!")
        self.callback_guardar()
        self.root.destroy()

    def nombre_existe(self, alter_ego):
        if not os.path.exists("personajes.txt"):
            return False
            
        with open("personajes.txt", "r") as f:
            for linea in f:
                datos = linea.strip().split(",")
                if len(datos) > 3 and datos[3].lower() == alter_ego.lower():
                    return True
        return False

[Clase Torneo pendiente]

#===================#
#Nombre: Inicio_Sesion
#===================#
#atributos:
#root (ventana tkinter)
#frame (Frame)
#usuario_entry (Entry)
#contra_entry (Entry)

#===================#
#métodos:
#__init__(root)
#crear_archivo_por_defecto()
#crear_widgets_login()
#validar_login()
#mostrar_bienvenida(nombre)
#abrir_sistema_torneos()
#===================#            
class Inicio_Sesion:
    """Clase que maneja el sistema de login y registro de usuarios."""
    
    def __init__(self, root):
        """
        Inicializa la ventana de login.
        
        Args:
            root (tk.Tk): Ventana principal
        """
        self.root = root
        self.root.title("Sistema de Login")
        self.root.geometry("400x300")
        
        if not os.path.exists("contraseñas.txt"):
            self.crear_archivo_por_defecto()
        
        self.crear_widgets_login()
    
    def crear_archivo_por_defecto(self):
        """Crea el archivo de contraseñas con usuarios por defecto."""
        with open("contraseñas.txt", "w", encoding="utf-8") as f:
            f.write("Sebas,Seb,1234\n")
            f.write("Hackney Hac,1234\n")
            f.write("admin,admin,admin\n")
    
    def crear_widgets_login(self):
        """Crea los widgets de la interfaz de login."""
        for widget in self.root.winfo_children():
            widget.destroy()
        
        self.frame = tk.Frame(self.root, padx=20, pady=20)
        self.frame.pack(expand=True)
        
        tk.Label(self.frame, text="INICIO DE SESIÓN", font=("Arial", 14, "bold")).grid(row=0, columnspan=2, pady=10)
        
        tk.Label(self.frame, text="Usuario:").grid(row=1, column=0, sticky="w", pady=5)
        self.usuario_entry = tk.Entry(self.frame)
        self.usuario_entry.grid(row=1, column=1, pady=5)
        
        tk.Label(self.frame, text="Contraseña:").grid(row=2, column=0, sticky="w", pady=5)
        self.contra_entry = tk.Entry(self.frame, show="*")
        self.contra_entry.grid(row=2, column=1, pady=5)
        
        tk.Button(self.frame, text="Ingresar", command=self.validar_login).grid(row=3, columnspan=2, pady=10)
    
    def validar_login(self):
        """Valida las credenciales ingresadas por el usuario."""
        usuario = self.usuario_entry.get()
        contra = self.contra_entry.get()
        
        if not usuario or not contra:
            messagebox.showwarning("Error", "Debe ingresar usuario y contraseña")
            return
        
        with open("contraseñas.txt", "r", encoding="utf-8") as f:
            for linea in f:
                datos = linea.strip().split(",")
                if len(datos) == 3:
                    nombre, user, password = datos
                    if user == usuario and password == contra:
                        self.mostrar_bienvenida(nombre)
                        return
        
        messagebox.showerror("Error", "Usuario o contraseña incorrectos")
    
    def mostrar_bienvenida(self, nombre):
        """Muestra la pantalla de bienvenida después del login."""
        for widget in self.root.winfo_children():
            widget.destroy()
        
        frame = tk.Frame(self.root, padx=20, pady=20)
        frame.pack(expand=True)
        
        tk.Label(
            frame, 
            text=f"¡Bienvenido/a {nombre}!", 
            font=("Arial", 16, "bold"),
            fg="blue"
        ).pack(pady=20)
        
        tk.Button(
            frame,
            text="Continuar al Menú Principal",
            command=self.abrir_sistema_torneos,
            width=20,
            height=2
        ).pack(pady=20)
    
    def abrir_sistema_torneos(self):
        """Inicia el sistema principal de torneos."""
        for widget in self.root.winfo_children():
            widget.destroy()
        
        SistemaTorneos(self.root)

    def jugar_torneo(self):
        if not self.torneos:
            messagebox.showwarning("Advertencia", "No hay torneos creados")
            return
        top = tk.Toplevel(self.root)
        top.title("Seleccionar Torneo")
        top.geometry("600x400")
        tk.Label(top, text="SELECCIONE UN TORNEO", font=("Arial", 14, "bold")).pack(pady=10)
        frame_lista = tk.Frame(top)
        frame_lista.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        scrollbar = tk.Scrollbar(frame_lista)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        lista_torneos = tk.Listbox(
            frame_lista, yscrollcommand=scrollbar.set,
            font=("Arial", 12), selectmode=tk.SINGLE
        )
        lista_torneos.pack(fill=tk.BOTH, expand=True)
        scrollbar.config(command=lista_torneos.yview)
        for torneo in self.torneos:
            lista_torneos.insert(tk.END, f"{torneo.nombre} - {torneo.fecha}")
        btn_frame = tk.Frame(top)
        btn_frame.pack(pady=20)
        def iniciar():
            seleccion = lista_torneos.curselection()
            if not seleccion:
                messagebox.showwarning("Advertencia", "Selecciona un torneo primero")
                return
            idx = seleccion[0]
            self.torneo_actual = self.torneos[idx]
            top.destroy()
            # Aquí deberías llamar la función que maneja el desarrollo del torneo seleccionado,
            # por ejemplo, self._torneo_round_por_round() o lo que tengas definido.
            # Si no la tienes, puedes poner un messagebox temporal:
            messagebox.showinfo("Info", f"Inicia el torneo: {self.torneo_actual.nombre}")
        tk.Button(
            btn_frame, text="INICIAR TORNEO", command=iniciar,
            bg="#4CAF50", fg="white", font=("Arial", 12, "bold"),
            padx=20, pady=10
        ).pack(side=tk.LEFT, padx=10)
        tk.Button(
            btn_frame, text="CANCELAR", command=top.destroy,
            bg="#f44336", fg="white", font=("Arial", 12),
            padx=20, pady=10
        ).pack(side=tk.LEFT, padx=10)


#===================#
#Nombre: Lucha
#===================#
#atributos:
#nombre_alter_primero
#nombre_alter_segundo
#nombre_torneo
#ganador_round_1
#ganador_round_2
#ganador_round_3
#ganador_lucha

#===================#
#metodos:
#registrar_ganador(round_num,ganador)
#realizar_lucha()
#determinar_ganador()
#===================#


class Lucha:
    def __init__(self,primer_luchador,segundo_luchador,nombre_torneo=None):
        if not isinstance(primer_luchador,Luchador) or not isinstance(segundo_luchador,Luchador):
            raise ValueError("Los nombres de los alter ego deben ser Luchadores")
        self.primer_luchador=primer_luchador
        self.segundo_luchador=segundo_luchador
        self.ganador_round_1=None
        self.ganador_round_2=None
        self.ganador_round_3=None
        self.ganador_lucha=None
        self.nombre_torneo=nombre_torneo or "Sin Torneo"
    def registrar_ganador(self,round_num,ganador):
        if round_num == 1:
            self.ganador_round_1=ganador
        if round_num == 2:
            self.ganador_round_2=ganador
        if round_num == 3:
            self.ganador_round_3=ganador

        with open ("Luchas.txt","a") as archivo:
            archivo.write(self.primer_luchador.alter_ego + "," +self.segundo_luchador.alter_ego + "," +
                          "#"+ str(round_num)+"," + ganador+","+ self.nombre_torneo + "\n")
    def realizar_lucha(self):
        for round_num in range(1,4):
            stats_elegidos =random.sample(list(self.primer_luchador.stats.keys()),8)

            victorias_peleador1=0
            victorias_peleador2=0
            
            for stat in stats_elegidos:

                valor_peleador1=self.primer_luchador.stats.get(stat,0)
                valor_peleador2=self.segundo_luchador.stats.get(stat,0)

                if valor_peleador1 > valor_peleador2:
                    victorias_peleador1 +=1

                if valor_peleador2 > valor_peleador1:
                    victorias_peleador2 +=1
                    
            if victorias_peleador1 > victorias_peleador2:
                self.registrar_ganador(round_num,self.primer_luchador.alter_ego)
            
            if victorias_peleador2 > victorias_peleador1:
                self.registrar_ganador(round_num,self.segundo_luchador.alter_ego)

        self.determinar_ganador()

    def determinar_ganador(self):
        primero_victorias= 0
        segundo_victorias=0

        for ganador in[self.ganador_round_1,self.ganador_round_2,self.ganador_round_3]:
            
            if ganador == self.primer_luchador.alter_ego:
                primero_victorias +=1
            elif ganador == self.segundo_luchador.alter_ego:
                segundo_victorias +=1
        if primero_victorias > segundo_victorias:
            self.ganador_lucha = self.primer_luchador.alter_ego
            
        elif segundo_victorias > primero_victorias:
            self.ganador_lucha = self.segundo_luchador.alter_ego
        else:
            self.ganador_lucha ="Empate"



MODOS_TORNEO = ["Manual", "Persona vs Programa", "Programa vs Programa"]

class Torneo:
    def __init__(self, nombre, fecha, lugar, heroes, villanos, luchas, modo):
        self.nombre = nombre
        self.fecha = fecha
        self.lugar = lugar
        self.heroes = heroes
        self.villanos = villanos
        self.luchas = luchas
        self.modo = modo

    def resumen_txt(self):
        txt = []
        txt.append("==== TORNEO ====")
        txt.append(f"Nombre: {self.nombre}")
        txt.append(f"Fecha: {self.fecha}")
        txt.append(f"Lugar: {self.lugar}")
        txt.append(f"Modo: {self.modo}")
        txt.append(f"Número de luchas: {len(self.luchas)}")
        txt.append("Héroes:")
        for h in self.heroes:
            txt.append(f"  - {h.alter_ego}")
        txt.append("Villanos:")
        for v in self.villanos:
            txt.append(f"  - {v.alter_ego}")
        txt.append("Luchas:")
        for i, lucha in enumerate(self.luchas, 1):
            txt.append(f"  Lucha {i}: {lucha['heroe'].alter_ego} vs {lucha['villano'].alter_ego}")
        txt.append("================\n")
        return "\n".join(txt)



class Estadisticas:
    def __init__(self, sistema_torneos):
        self.sistema = sistema_torneos

    def generar_reporte_completo(self):
        """Genera un diccionario con todas las estadísticas"""
        return {
            "torneos_realizados": self.cantidad_torneos(),
            "heroes_creados": self.cantidad_heroes(),
            "villanos_creados": self.cantidad_villanos(),
            "heroe_mas_ganador": self.heroe_mas_ganador(),
            "heroe_mas_perdedor": self.heroe_mas_perdedor(),
            "villano_mas_ganador": self.villano_mas_ganador(),
            "villano_mas_perdedor": self.villano_mas_perdedor(),
            "heroe_mas_participante": self.heroe_mas_participante(),
            "villano_mas_participante": self.villano_mas_participante()
        }

    def cantidad_torneos(self):
        """Retorna la cantidad de torneos realizados"""
        try:
            with open("Torneos.txt", "r") as f:
                return len(f.readlines())
        except FileNotFoundError:
            return 0

    def cantidad_heroes(self):
        """Retorna la cantidad de héroes creados"""
        return sum(1 for p in self.sistema.personajes if p.tipo == "Héroe")

    def cantidad_villanos(self):
        """Retorna la cantidad de villanos creados"""
        return sum(1 for p in self.sistema.personajes if p.tipo == "Villano")

    def heroe_mas_ganador(self):
        """Retorna el héroe con más victorias"""
        heroes = [p for p in self.sistema.personajes if p.tipo == "Héroe"]
        if not heroes:
            return "No hay héroes registrados"
        return max(heroes, key=lambda x: x.victorias).alter_ego

    def heroe_mas_perdedor(self):
        """Retorna el héroe con más derrotas"""
        heroes = [p for p in self.sistema.personajes if p.tipo == "Héroe"]
        if not heroes:
            return "No hay héroes registrados"
        return max(heroes, key=lambda x: x.derrotas).alter_ego

    def villano_mas_ganador(self):
        """Retorna el villano con más victorias"""
        villanos = [p for p in self.sistema.personajes if p.tipo == "Villano"]
        if not villanos:
            return "No hay villanos registrados"
        return max(villanos, key=lambda x: x.victorias).alter_ego

    def villano_mas_perdedor(self):
        """Retorna el villano con más derrotas"""
        villanos = [p for p in self.sistema.personajes if p.tipo == "Villano"]
        if not villanos:
            return "No hay villanos registrados"
        return max(villanos, key=lambda x: x.derrotas).alter_ego

    def heroe_mas_participante(self):
        """Retorna el héroe que aparece en más torneos"""
        participaciones = {}
        
        try:
            with open("Torneos.txt", "r") as f:
                for linea in f:
                    datos = linea.strip().split(',')
                    nombre_torneo = datos[0].strip("'")
                    
                    # Buscar en Luchas.txt las participaciones de este torneo
                    with open("Luchas.txt", "r") as l:
                        for lucha in l:
                            datos_lucha = lucha.strip().split(',')
                            if datos_lucha[4].strip() == nombre_torneo:
                                heroe = datos_lucha[0].strip()
                                participaciones[heroe] = participaciones.get(heroe, 0) + 1
        except FileNotFoundError:
            return "No hay datos de torneos"
            
        if not participaciones:
            return "No hay participaciones registradas"
            
        return max(participaciones.items(), key=lambda x: x[1])[0]

    def villano_mas_participante(self):
        """Retorna el villano que aparece en más torneos"""
        participaciones = {}
        
        try:
            with open("Torneos.txt", "r") as f:
                for linea in f:
                    datos = linea.strip().split(',')
                    nombre_torneo = datos[0].strip("'")
                    
                    # Buscar en Luchas.txt las participaciones de este torneo
                    with open("Luchas.txt", "r") as l:
                        for lucha in l:
                            datos_lucha = lucha.strip().split(',')
                            if datos_lucha[4].strip() == nombre_torneo:
                                villano = datos_lucha[1].strip()
                                participaciones[villano] = participaciones.get(villano, 0) + 1
        except FileNotFoundError:
            return "No hay datos de torneos"
            
        if not participaciones:
            return "No hay participaciones registradas"
            
        return max(participaciones.items(), key=lambda x: x[1])[0]

# Punto de entrada principal
if __name__ == "__main__":
    root = tk.Tk()
    sesion = Inicio_Sesion(root)
    root.mainloop()
